const std = @import("std");
const builtin = @import("builtin");

const common = @import("../common/data.zig");
const optional = @import("../common/optional.zig");
const options = @import("../common/options.zig");
const protocol = @import("../common/protocol.zig");
const rational = @import("../common/rational.zig");
const rng = @import("../common/rng.zig");

const calc = @import("calc.zig");
const chance = @import("chance.zig");
const data = @import("data.zig");

const assert = std.debug.assert;

const expectEqual = std.testing.expectEqual;
const expectEqualSlices = std.testing.expectEqualSlices;

const Choice = common.Choice;
const Player = common.Player;

const Optional = optional.Optional;

const showdown = options.showdown;

const PSRNG = rng.PSRNG;

const DVs = data.DVs;
const Move = data.Move;
const MoveSlot = data.MoveSlot;
const Species = data.Species;
const Stats = data.Stats;
const Status = data.Status;

const Action = chance.Action;
const Actions = chance.Actions;

const endian = builtin.cpu.arch.endian();

/// Configuration options controlling the domain of valid Pokémon that can be generated by the
/// random generator helpers.
pub const Options = struct {
    /// Whether to generate Pokémon adhering to "Cleric Clause".
    cleric: bool = showdown,
    /// Whether to generate Pokémon with moves that contain bugs on Pokémon Showdown that are
    /// unimplementable in the engine.
    block: bool = showdown,
    // FIXME: remove once durations work with -Dchance
    durations: bool = false,
};

/// Helpers to simplify initialization of a Generation I battle.
pub const Battle = struct {
    /// Initializes a Generation I battle with the teams specified by `p1` and `p2`
    /// and an RNG whose seed is derived from `seed`.
    pub fn init(
        seed: u64,
        p1: []const Pokemon,
        p2: []const Pokemon,
    ) data.Battle(data.PRNG) {
        var rand = PSRNG.init(seed);
        return .{
            .rng = prng(&rand),
            .sides = .{ Side.init(p1), Side.init(p2) },
        };
    }

    /// Initializes a Generation I battle with the teams specified by `p1` and `p2`
    /// and a FixedRNG that returns the provided `rolls`.
    pub fn fixed(
        comptime rolls: anytype,
        p1: []const Pokemon,
        p2: []const Pokemon,
    ) data.Battle(rng.FixedRNG(1, rolls.len)) {
        return .{
            .rng = .{ .rolls = rolls },
            .sides = .{ Side.init(p1), Side.init(p2) },
        };
    }

    /// Returns a Generation I battle that is randomly generated based on the `rand` and `opts`.
    pub fn random(rand: *PSRNG, opts: Options) data.Battle(data.PRNG) {
        return .{
            .rng = prng(rand),
            .turn = 0,
            .last_damage = 0,
            .sides = .{ Side.random(rand, opts), Side.random(rand, opts) },
        };
    }
};

fn prng(rand: *PSRNG) data.PRNG {
    return .{
        .src = .{
            .seed = if (showdown)
                rand.newSeed()
            else seed: {
                // GLITCH: The initial RNG seed in Gen I link battles is heavily constrained
                // https://www.smogon.com/forums/threads/rng-in-rby-link-battles.3746779
                var seed = [_]u8{ 0, 0, 0, 0, 0, 0, 0, 0, 0 };

                // Bytes in seed can only range from 0-252, not 0-255
                const max: u8 = 253;
                // Instructions take multiples of 4 cycles to execute
                var timer: u16 = 4 * rand.range(u16, 0, 16384);
                var add: u8 = rand.range(u8, 0, 256);
                var carry: u8 = 0;

                var i: u8 = 0;
                while (i < seed.len) {
                    const div: u8 = @intCast(timer >> 8);
                    add +%= div +% carry;
                    if (add < max) {
                        seed[i] = add;
                        i += 1;
                        timer +%= 472;
                        carry = 1;
                    } else {
                        timer +%= 452;
                        carry = 0;
                    }
                }
                break :seed seed;
            },
        },
    };
}

/// Helpers to simplify initialization of a Generation I side.
pub const Side = struct {
    /// Initializes a Generation I side with the team specified by `ps`.
    pub fn init(ps: []const Pokemon) data.Side {
        assert(ps.len > 0 and ps.len <= 6);
        var side = data.Side{};

        for (0..ps.len) |i| {
            side.pokemon[i] = Pokemon.init(ps[i]);
            side.order[i] = @as(u4, @intCast(i)) + 1;
        }
        return side;
    }

    /// Returns a Generation I side that is randomly generated based on the `rand` and `opts`.
    pub fn random(rand: *PSRNG, opts: Options) data.Side {
        const n = if (rand.chance(u8, 1, 100)) rand.range(u4, 1, 5 + 1) else 6;
        var side = data.Side{};

        for (0..n) |i| {
            side.pokemon[i] = Pokemon.random(rand, opts);
            side.order[i] = @as(u4, @intCast(i)) + 1;
        }

        return side;
    }
};

/// The maximum stat experience possible in Generation I.
pub const EXP = 0xFFFF;

/// Helpers to simplify initialization of a Generation I Pokémon.
pub const Pokemon = struct {
    /// The Pokémon's species.
    species: Species,
    /// The Pokémon's moves (assumed to all have the max possible PP).
    moves: []const Move,
    /// The Pokémon's current HP (defaults to 100% if not specified).
    hp: ?u16 = null,
    /// The Pokémon's current status.
    status: u8 = 0,
    /// The Pokémon's level.
    level: u8 = 100,
    /// The Pokémon's DVs.
    dvs: DVs = .{},
    /// The Pokémon's stat experience.
    stats: Stats(u16) = .{ .hp = EXP, .atk = EXP, .def = EXP, .spe = EXP, .spc = EXP },

    /// Initializes a Generation I Pokémon based on the information in `p`.
    pub fn init(p: Pokemon) data.Pokemon {
        var pokemon = data.Pokemon{};
        pokemon.species = p.species;
        const species = Species.get(p.species);
        inline for (@typeInfo(@TypeOf(pokemon.stats)).Struct.fields) |field| {
            const hp = comptime std.mem.eql(u8, field.name, "hp");
            const spc =
                comptime std.mem.eql(u8, field.name, "spa") or std.mem.eql(u8, field.name, "spd");
            @field(pokemon.stats, field.name) = Stats(u16).calc(
                field.name,
                @field(species.stats, field.name),
                if (hp) p.dvs.hp() else if (spc) p.dvs.spc else @field(p.dvs, field.name),
                @field(p.stats, field.name),
                p.level,
            );
        }
        assert(p.moves.len > 0 and p.moves.len <= 4);
        for (p.moves, 0..) |m, j| {
            pokemon.moves[j].id = m;
            // NB: PP can be at most 61 legally (though can overflow to 63)
            pokemon.moves[j].pp = @intCast(@min(Move.pp(m) / 5 * 8, 61));
        }
        if (p.hp) |hp| {
            pokemon.hp = hp;
        } else {
            pokemon.hp = pokemon.stats.hp;
        }
        pokemon.status = p.status;
        pokemon.types = species.types;
        pokemon.level = p.level;
        return pokemon;
    }

    /// Returns a Generation I Pokémon that is randomly generated based on the `rand` and `opts`.
    pub fn random(rand: *PSRNG, opt: Options) data.Pokemon {
        const s: Species = @enumFromInt(rand.range(u8, 1, Species.size + 1));
        const species = Species.get(s);
        const lvl = if (rand.chance(u8, 1, 20)) rand.range(u8, 1, 99 + 1) else 100;
        var stats: Stats(u16) = .{};
        const dvs = DVs.random(rand);
        inline for (@typeInfo(@TypeOf(stats)).Struct.fields) |field| {
            @field(stats, field.name) = Stats(u16).calc(
                field.name,
                @field(species.stats, field.name),
                if (comptime std.mem.eql(u8, field.name, "hp"))
                    dvs.hp()
                else
                    @field(dvs, field.name),
                if (rand.chance(u8, 1, 20)) rand.range(u16, 0, EXP + 1) else EXP,
                lvl,
            );
        }

        var ms = [_]MoveSlot{.{}} ** 4;
        const n = if (rand.chance(u8, 1, 100)) rand.range(u4, 1, 3 + 1) else 4;
        for (0..n) |i| {
            var m: Move = .None;
            sample: while (true) {
                m = @enumFromInt(rand.range(u8, 1, Move.size - 1 + 1));
                if (opt.durations and durations(m)) continue :sample;
                if (opt.block and blocked(m)) continue :sample;
                for (0..i) |j| if (ms[j].id == m) continue :sample;
                break;
            }
            const pp_ups: u8 =
                if (!opt.cleric and rand.chance(u8, 1, 10)) rand.range(u2, 0, 2 + 1) else 3;
            // NB: PP can be at most 61 legally (though can overflow to 63)
            const max_pp: u8 = @intCast(Move.pp(m) + pp_ups * @min(Move.pp(m) / 5, 7));
            ms[i] = .{
                .id = m,
                .pp = if (opt.cleric) max_pp else rand.range(u8, 0, max_pp + 1),
            };
        }

        return .{
            .species = s,
            .types = species.types,
            .level = lvl,
            .stats = stats,
            .hp = if (opt.cleric) stats.hp else rand.range(u16, 0, stats.hp + 1),
            .status = if (!opt.cleric and rand.chance(u8, 1, 6 + 1))
                0 | (@as(u8, 1) << rand.range(u3, 1, 6 + 1))
            else
                0,
            .moves = ms,
        };
    }
};

fn blocked(m: Move) bool {
    // Binding moves are borked but only via Mirror Move / Metronome which are already blocked
    return switch (m) {
        .Mimic, .Metronome, .MirrorMove, .Transform => true,
        else => false,
    };
}

fn durations(m: Move) bool {
    // Any moves that have effects that result in duration tracking with -Dchance
    return switch (Move.get(m).effect) {
        .Confusion,
        .Bide,
        .Sleep,
        .Rage,
        .Binding,
        .Thrashing,
        .ConfusionChance,
        .Disable,
        .Metronome,
        => true,
        else => false,
    };
}

/// Convenience helper to create a move-type choice for the provided move slot.
pub fn move(slot: u4) Choice {
    return .{ .type = .Move, .data = slot };
}

/// Convenience helper to create a switch-type choice for the provided team slot.
pub fn swtch(slot: u4) Choice {
    return .{ .type = .Switch, .data = slot };
}

const NONE = @intFromEnum(Optional(bool).None);

/// Helper functions that efficiently return valid ranges for various RNG events based on the
/// state of an `Action` and other events to be used to construct a "transitions" function.
pub const Rolls = struct {
    const PLAYER_NONE = [_]Optional(Player){.None};
    const PLAYERS = [_]Optional(Player){ .P1, .P2 };

    /// Returns a slice with the correct range of values for speed ties given the `action` state.
    pub fn speedTie(action: Action) []const Optional(Player) {
        return if (@field(action, "speed_tie") == .None) &PLAYER_NONE else &PLAYERS;
    }

    const BOOL_NONE = [_]Optional(bool){.None};
    const BOOLS = [_]Optional(bool){ .false, .true };

    /// Returns a slice with the correct range of values for hits given the `action` state
    /// and the state of the `parent` (whether the player's Pokémon was fully paralyzed).
    pub fn hit(action: Action, parent: Optional(bool)) []const Optional(bool) {
        if (parent == .true) return &BOOL_NONE;
        return if (@field(action, "hit") == .None) &BOOL_NONE else &BOOLS;
    }

    /// Returns a slice with the correct range of values for critical hits given the `action` state
    /// and the state of the `parent` (whether the player's Pokémon's move hit).
    pub fn criticalHit(
        action: Action,
        parent: Optional(bool),
    ) []const Optional(bool) {
        if (parent == .false) return &BOOL_NONE;
        return if (@field(action, "critical_hit") == .None) &BOOL_NONE else &BOOLS;
    }

    /// Returns a slice with the correct range of values for secondary chances hits given the
    /// `action` state and the state of the `parent` (whether the player's Pokémon's move hit).
    pub fn secondaryChance(
        action: Action,
        parent: Optional(bool),
    ) []const Optional(bool) {
        if (parent == .false) return &BOOL_NONE;
        return if (@field(action, "secondary_chance") == .None) &BOOL_NONE else &BOOLS;
    }

    /// The min and max bounds on iteration over damage rolls.
    pub const Range = struct { min: u9, max: u9 };

    /// Returns the range bounding damage rolls given the `action` state and the state of
    /// the `parent` (whether the player's Pokémon's move hit).
    pub fn damage(action: Action, parent: Optional(bool)) Range {
        return if (parent == .false or @field(action, "damage") == 0)
            .{ .min = 0, .max = 1 }
        else
            .{ .min = 217, .max = 256 };
    }

    /// Returns the max damage roll which will produce the same damage as `roll`
    /// given the base damage in `summaries`.
    pub fn coalesce(player: Player, roll: u8, summaries: *calc.Summaries, cap: bool) !u8 {
        if (roll == 0) return roll;

        const dmg = summaries.get(player.foe()).damage;
        if (dmg.base == 0 or (cap and dmg.capped)) return 255;

        // Closed form solution for max damage roll provided by Orion Taylor (taylorott)
        return @min(255, roll + ((254 - ((@as(u32, dmg.base) * roll) % 255)) / dmg.base));
    }

    /// Returns a slice with the correct range of values for confused given the `action` state
    /// and the state of the `parent` (the player's Pokémon's remaining confusion turns).
    pub fn confused(action: Action, parent: u4) []const Optional(bool) {
        return if (parent == 0 or @field(action, "confused") == .None) &BOOL_NONE else &BOOLS;
    }

    /// Returns a slice with the correct range of values for paralysis given the `action` state
    /// and the state of the `parent` (whether the player's Pokémon was confused).
    pub fn paralyzed(action: Action, parent: Optional(bool)) []const Optional(bool) {
        if (parent == .true) return &BOOL_NONE;
        return if (@field(action, "paralyzed") == .None) &BOOL_NONE else &BOOLS;
    }

    const DURATION_NONE = [_]u1{0};
    const DURATION = [_]u1{1};

    /// Returns a slice with a range of values for duration given the `action` state
    /// and the state of the `parent` (whether the player's Pokémon's move hit).
    pub fn duration(action: Action, parent: Optional(bool)) []const u1 {
        if (parent == .false) return &DURATION_NONE;
        return if (@field(action, "duration") == 0) &DURATION_NONE else &DURATION;
    }

    const U3_NONE = [_]u3{0};
    const U3_FORCED = [_]u3{1};

    /// Returns a slice with a range of values for sleep given the `action` and `origin` states.
    pub inline fn sleep(action: Action, origin: Action) []const u3 {
        const a = @field(action.durations, "sleep");
        const o = @field(origin.durations, "sleep");
        if (o == a) return if (o == 0) &U3_NONE else &[_]u3{o};
        assert(a == 0 or a == o + 1);
        return if (o >= 7) &U3_NONE else &[_]u3{ 0, o + 1 };
    }

    const DISABLE_NONE = [_]u4{0};

    /// Returns a slice with a range of values for disable given the `action` and `origin` states
    /// and the state of the `parent` (the player's Pokémon's remaining sleep turns).
    pub inline fn disable(action: Action, origin: Action, parent: u4) []const u4 {
        if (parent > 0) return &DISABLE_NONE;
        const a = @field(action.durations, "disable");
        const o = @field(origin.durations, "disable");
        if (o == a) return if (o == 0) &DISABLE_NONE else &[_]u4{o};
        assert(a == 0 or a == o + 1);
        return if (o >= 8) &DISABLE_NONE else &[_]u4{ 0, o + 1 };
    }

    /// Returns a slice with a range of values for confusion given the `action` and `origin` states
    /// and the state of the `parent` (the player's remaining sleep turns).
    pub inline fn confusion(action: Action, origin: Action, parent: u4) []const u3 {
        if (parent > 0) return &U3_NONE;
        const a = @field(action.durations, "confusion");
        const o = @field(origin.durations, "confusion");
        if (o == a) return if (o == 0) &U3_NONE else &[_]u3{o};
        assert(a == 0 or a == o + 1);
        return if (o >= 5) &U3_NONE else if (o < 2)
            if (a == 0) &U3_NONE else &U3_FORCED
        else
            &[_]u3{ 0, o + 1 };
    }

    /// Returns a slice with a range of values for attacking given the `action` and `origin` states
    /// and the state of the `parent` (whether the player's Pokémon was fully paralyzed).
    pub inline fn attacking(action: Action, origin: Action, parent: Optional(bool)) []const u3 {
        if (parent == .true) return &U3_NONE;
        const a = @field(action.durations, "attacking");
        const o = @field(origin.durations, "attacking");
        if (o == a) return if (o == 0) &U3_NONE else &[_]u3{o};
        assert(a == 0 or a == o + 1);
        return if (o >= 3) &U3_NONE else if (o < 2)
            if (a == 0) &U3_NONE else &U3_FORCED
        else
            &[_]u3{ 0, o + 1 };
    }

    /// Returns a slice with a range of values for binding given the `action` and `origin` states
    /// and the state of the `parent` (whether the player's Pokémon was fully paralyzed).
    pub inline fn binding(action: Action, origin: Action, parent: Optional(bool)) []const u3 {
        if (parent == .true) return &U3_NONE;
        const a = @field(action.durations, "binding");
        const o = @field(origin.durations, "binding");
        if (o == a) return if (o == 0) &U3_NONE else &[_]u3{o};
        assert(a == 0 or a == o + 1);
        return if (o >= 4) &U3_NONE else &[_]u3{ 0, o + 1 };
    }

    const SLOT_NONE = [_]u4{0};
    const SLOT = [_]u4{ 1, 2, 3, 4 };

    /// Returns a slice with a range of values for move slots given the `action` state
    /// and the state of the `parent` (whether the player's Pokémon's move hit).
    ///
    /// These slots may or **may not be valid** as slots may be unset / have 0 PP.
    pub fn moveSlot(action: Action, parent: Optional(bool)) []const u4 {
        if (parent == .false) return &SLOT_NONE;
        return if (@field(action, "move_slot") == 0) &SLOT_NONE else &SLOT;
    }

    const MULTI_NONE = [_]u4{0};
    const MULTI = [_]u4{ 2, 3, 4, 5 };

    /// Returns a slice with the correct range of values for multi hit given the `action` state
    /// and the state of the `parent` (whether the player's Pokémon's move hit).
    pub fn multiHit(action: Action, parent: Optional(bool)) []const u4 {
        if (parent == .false) return &MULTI_NONE;
        return if (@field(action, "multi_hit") == 0) &MULTI_NONE else &MULTI;
    }

    const PSYWAVE_NONE = [_]u8{0};
    const PSYWAVE = init: {
        var rolls: [150]u8 = undefined;
        for (0..150) |i| rolls[i] = i + 1;
        break :init rolls;
    };

    /// Returns a slice with the correct range of values for psywave given the `action` state,
    /// the `side`, and the state of the `parent` (whether the player's Pokémon's move hit).
    pub fn psywave(
        action: Action,
        side: *data.Side,
        parent: Optional(bool),
    ) []const u8 {
        if (parent == .false) return &PSYWAVE_NONE;
        return if (@field(action, "psywave") == 0)
            &PSYWAVE_NONE
        else
            PSYWAVE[0 .. @as(u16, side.stored().level) * 3 / 2];
    }

    const MOVE_NONE = [_]Move{.None};

    /// Returns a slice with the correct range of values for metronome given the `action` state.
    pub fn metronome(action: Action) []const Move {
        return if (@field(action, "metronome") == .None) &MOVE_NONE else &Move.METRONOME;
    }
};

test "Rolls.speedTie" {
    const actions: Actions = .{ .p1 = .{ .speed_tie = .P2 } };
    try expectEqualSlices(Optional(Player), &.{ .P1, .P2 }, Rolls.speedTie(actions.p1));
    try expectEqualSlices(Optional(Player), &.{.None}, Rolls.speedTie(actions.p2));
}

test "Rolls.damage" {
    const actions: Actions = .{ .p2 = .{ .damage = 221 } };
    try expectEqual(Rolls.Range{ .min = 0, .max = 1 }, Rolls.damage(actions.p1, .None));
    try expectEqual(Rolls.Range{ .min = 217, .max = 256 }, Rolls.damage(actions.p2, .None));
    try expectEqual(Rolls.Range{ .min = 0, .max = 1 }, Rolls.damage(actions.p2, .false));
}

test "Rolls.coalesce" {
    var summaries =
        calc.Summaries{ .p1 = .{ .damage = .{ .base = 74, .final = 69, .capped = true } } };
    try expectEqual(0, try Rolls.coalesce(.P2, 0, &summaries, false));
    try expectEqual(241, try Rolls.coalesce(.P2, 238, &summaries, false));
    try expectEqual(255, try Rolls.coalesce(.P2, 238, &summaries, true));
    summaries.p1.damage.final = 74;
    try expectEqual(217, try Rolls.coalesce(.P2, 217, &summaries, false));
    try expectEqual(255, try Rolls.coalesce(.P2, 217, &summaries, true));
}

test "Rolls.hit" {
    const actions: Actions = .{ .p2 = .{ .hit = .true } };
    try expectEqualSlices(Optional(bool), &.{.None}, Rolls.hit(actions.p1, .None));
    try expectEqualSlices(Optional(bool), &.{ .false, .true }, Rolls.hit(actions.p2, .None));
    try expectEqualSlices(Optional(bool), &.{.None}, Rolls.hit(actions.p2, .true));
    try expectEqualSlices(Optional(bool), &.{ .false, .true }, Rolls.hit(actions.p2, .false));
}

test "Rolls.secondaryChance" {
    const actions: Actions = .{ .p1 = .{ .secondary_chance = .true } };
    try expectEqualSlices(
        Optional(bool),
        &.{ .false, .true },
        Rolls.secondaryChance(actions.p1, .None),
    );
    try expectEqualSlices(Optional(bool), &.{.None}, Rolls.secondaryChance(actions.p1, .false));
    try expectEqualSlices(Optional(bool), &.{.None}, Rolls.secondaryChance(actions.p2, .None));
}

test "Rolls.criticalHit" {
    const actions: Actions = .{ .p1 = .{ .critical_hit = .true } };
    try expectEqualSlices(
        Optional(bool),
        &.{ .false, .true },
        Rolls.criticalHit(actions.p1, .None),
    );
    try expectEqualSlices(Optional(bool), &.{.None}, Rolls.criticalHit(actions.p1, .false));
    try expectEqualSlices(Optional(bool), &.{.None}, Rolls.criticalHit(actions.p2, .None));
}

test "Rolls.confused" {
    const actions: Actions = .{ .p2 = .{ .confused = .true } };
    try expectEqualSlices(Optional(bool), &.{.None}, Rolls.confused(actions.p1, 1));
    try expectEqualSlices(Optional(bool), &.{ .false, .true }, Rolls.confused(actions.p2, 1));
    try expectEqualSlices(Optional(bool), &.{.None}, Rolls.confused(actions.p2, 0));
}

test "Rolls.paralyzed" {
    const actions: Actions = .{ .p2 = .{ .paralyzed = .true } };
    try expectEqualSlices(Optional(bool), &.{.None}, Rolls.paralyzed(actions.p1, .None));
    try expectEqualSlices(Optional(bool), &.{ .false, .true }, Rolls.paralyzed(actions.p2, .None));
    try expectEqualSlices(Optional(bool), &.{ .false, .true }, Rolls.paralyzed(actions.p2, .false));
    try expectEqualSlices(Optional(bool), &.{.None}, Rolls.paralyzed(actions.p2, .true));
}

test "Rolls.duration" {
    const actions: Actions = .{ .p2 = .{ .duration = 3 } };
    try expectEqualSlices(u1, &.{0}, Rolls.duration(actions.p1, .None));
    try expectEqualSlices(u1, &.{1}, Rolls.duration(actions.p2, .None));
    try expectEqualSlices(u1, &.{0}, Rolls.duration(actions.p2, .false));
}

test "Rolls.sleep" {
    try expectEqualSlices(u3, &.{0}, Rolls.sleep(
        .{ .durations = .{ .sleep = 0 } },
        .{ .durations = .{ .sleep = 0 } },
    ));
    try expectEqualSlices(u3, &.{ 0, 1 }, Rolls.sleep(
        .{ .durations = .{ .sleep = 1 } },
        .{ .durations = .{ .sleep = 0 } },
    ));
    try expectEqualSlices(u3, &.{ 0, 2 }, Rolls.sleep(
        .{ .durations = .{ .sleep = 0 } },
        .{ .durations = .{ .sleep = 1 } },
    ));
    try expectEqualSlices(u3, &.{1}, Rolls.sleep(
        .{ .durations = .{ .sleep = 1 } },
        .{ .durations = .{ .sleep = 1 } },
    ));
    try expectEqualSlices(u3, &.{ 0, 3 }, Rolls.sleep(
        .{ .durations = .{ .sleep = 0 } },
        .{ .durations = .{ .sleep = 2 } },
    ));
    try expectEqualSlices(u3, &.{ 0, 7 }, Rolls.sleep(
        .{ .durations = .{ .sleep = 7 } },
        .{ .durations = .{ .sleep = 6 } },
    ));
    try expectEqualSlices(u3, &.{0}, Rolls.sleep(
        .{ .durations = .{ .sleep = 0 } },
        .{ .durations = .{ .sleep = 7 } },
    ));
}

test "Rolls.disable" {
    try expectEqualSlices(u4, &.{0}, Rolls.disable(
        .{ .durations = .{ .disable = 0 } },
        .{ .durations = .{ .disable = 0 } },
        0,
    ));
    try expectEqualSlices(u4, &.{ 0, 1 }, Rolls.disable(
        .{ .durations = .{ .disable = 1 } },
        .{ .durations = .{ .disable = 0 } },
        0,
    ));
    try expectEqualSlices(u4, &.{ 0, 2 }, Rolls.disable(
        .{ .durations = .{ .disable = 0 } },
        .{ .durations = .{ .disable = 1 } },
        0,
    ));
    try expectEqualSlices(u4, &.{1}, Rolls.disable(
        .{ .durations = .{ .disable = 1 } },
        .{ .durations = .{ .disable = 1 } },
        0,
    ));
    try expectEqualSlices(u4, &.{ 0, 3 }, Rolls.disable(
        .{ .durations = .{ .disable = 0 } },
        .{ .durations = .{ .disable = 2 } },
        0,
    ));
    try expectEqualSlices(u4, &.{0}, Rolls.disable(
        .{ .durations = .{ .disable = 0 } },
        .{ .durations = .{ .disable = 2 } },
        1,
    ));
    try expectEqualSlices(u4, &.{ 0, 8 }, Rolls.disable(
        .{ .durations = .{ .disable = 8 } },
        .{ .durations = .{ .disable = 7 } },
        0,
    ));
    try expectEqualSlices(u4, &.{0}, Rolls.disable(
        .{ .durations = .{ .disable = 0 } },
        .{ .durations = .{ .disable = 8 } },
        0,
    ));
}

test "Rolls.confusion" {
    try expectEqualSlices(u3, &.{0}, Rolls.confusion(
        .{ .durations = .{ .confusion = 0 } },
        .{ .durations = .{ .confusion = 0 } },
        0,
    ));
    try expectEqualSlices(u3, &.{1}, Rolls.confusion(
        .{ .durations = .{ .confusion = 1 } },
        .{ .durations = .{ .confusion = 0 } },
        0,
    ));
    try expectEqualSlices(u3, &.{0}, Rolls.confusion(
        .{ .durations = .{ .confusion = 0 } },
        .{ .durations = .{ .confusion = 1 } },
        0,
    ));
    try expectEqualSlices(u3, &.{1}, Rolls.confusion(
        .{ .durations = .{ .confusion = 1 } },
        .{ .durations = .{ .confusion = 1 } },
        0,
    ));
    try expectEqualSlices(u3, &.{ 0, 3 }, Rolls.confusion(
        .{ .durations = .{ .confusion = 0 } },
        .{ .durations = .{ .confusion = 2 } },
        0,
    ));
    try expectEqualSlices(u3, &.{0}, Rolls.confusion(
        .{ .durations = .{ .confusion = 0 } },
        .{ .durations = .{ .confusion = 2 } },
        1,
    ));
    try expectEqualSlices(u3, &.{ 0, 5 }, Rolls.confusion(
        .{ .durations = .{ .confusion = 5 } },
        .{ .durations = .{ .confusion = 4 } },
        0,
    ));
    try expectEqualSlices(u3, &.{0}, Rolls.confusion(
        .{ .durations = .{ .confusion = 0 } },
        .{ .durations = .{ .confusion = 5 } },
        0,
    ));
}

test "Rolls.attacking" {
    try expectEqualSlices(u3, &.{0}, Rolls.attacking(
        .{ .durations = .{ .attacking = 0 } },
        .{ .durations = .{ .attacking = 0 } },
        .false,
    ));
    try expectEqualSlices(u3, &.{1}, Rolls.attacking(
        .{ .durations = .{ .attacking = 1 } },
        .{ .durations = .{ .attacking = 0 } },
        .false,
    ));
    try expectEqualSlices(u3, &.{0}, Rolls.attacking(
        .{ .durations = .{ .attacking = 0 } },
        .{ .durations = .{ .attacking = 1 } },
        .false,
    ));
    try expectEqualSlices(u3, &.{1}, Rolls.attacking(
        .{ .durations = .{ .attacking = 1 } },
        .{ .durations = .{ .attacking = 1 } },
        .false,
    ));
    try expectEqualSlices(u3, &.{ 0, 3 }, Rolls.attacking(
        .{ .durations = .{ .attacking = 0 } },
        .{ .durations = .{ .attacking = 2 } },
        .false,
    ));
    try expectEqualSlices(u3, &.{0}, Rolls.attacking(
        .{ .durations = .{ .attacking = 0 } },
        .{ .durations = .{ .attacking = 2 } },
        .true,
    ));
    try expectEqualSlices(u3, &.{ 0, 3 }, Rolls.attacking(
        .{ .durations = .{ .attacking = 3 } },
        .{ .durations = .{ .attacking = 2 } },
        .false,
    ));
    try expectEqualSlices(u3, &.{0}, Rolls.attacking(
        .{ .durations = .{ .attacking = 0 } },
        .{ .durations = .{ .attacking = 3 } },
        .false,
    ));
}

test "Rolls.binding" {
    try expectEqualSlices(u3, &.{0}, Rolls.binding(
        .{ .durations = .{ .binding = 0 } },
        .{ .durations = .{ .binding = 0 } },
        .false,
    ));
    try expectEqualSlices(u3, &.{ 0, 1 }, Rolls.binding(
        .{ .durations = .{ .binding = 1 } },
        .{ .durations = .{ .binding = 0 } },
        .false,
    ));
    try expectEqualSlices(u3, &.{ 0, 2 }, Rolls.binding(
        .{ .durations = .{ .binding = 0 } },
        .{ .durations = .{ .binding = 1 } },
        .false,
    ));
    try expectEqualSlices(u3, &.{1}, Rolls.binding(
        .{ .durations = .{ .binding = 1 } },
        .{ .durations = .{ .binding = 1 } },
        .false,
    ));
    try expectEqualSlices(u3, &.{ 0, 3 }, Rolls.binding(
        .{ .durations = .{ .binding = 0 } },
        .{ .durations = .{ .binding = 2 } },
        .false,
    ));
    try expectEqualSlices(u3, &.{0}, Rolls.binding(
        .{ .durations = .{ .binding = 0 } },
        .{ .durations = .{ .binding = 2 } },
        .true,
    ));
    try expectEqualSlices(u3, &.{ 0, 4 }, Rolls.binding(
        .{ .durations = .{ .binding = 4 } },
        .{ .durations = .{ .binding = 3 } },
        .false,
    ));
    try expectEqualSlices(u3, &.{0}, Rolls.binding(
        .{ .durations = .{ .binding = 0 } },
        .{ .durations = .{ .binding = 4 } },
        .false,
    ));
}

test "Rolls.moveSlot" {
    const actions: Actions = .{ .p2 = .{ .move_slot = 3 } };
    try expectEqualSlices(u4, &.{0}, Rolls.moveSlot(actions.p1, .None));
    try expectEqualSlices(u4, &.{ 1, 2, 3, 4 }, Rolls.moveSlot(actions.p2, .None));
    try expectEqualSlices(u4, &.{0}, Rolls.moveSlot(actions.p2, .false));
}

test "Rolls.multiHit" {
    const actions: Actions = .{ .p2 = .{ .multi_hit = 3 } };
    try expectEqualSlices(u4, &.{0}, Rolls.multiHit(actions.p1, .None));
    try expectEqualSlices(u4, &.{ 2, 3, 4, 5 }, Rolls.multiHit(actions.p2, .None));
    try expectEqualSlices(u4, &.{0}, Rolls.multiHit(actions.p2, .false));
}

test "Rolls.metronome" {
    const actions: Actions = .{ .p2 = .{ .metronome = .Surf } };
    try expectEqualSlices(Move, &.{.None}, Rolls.metronome(actions.p1));
    try expectEqual(@as(Move, @enumFromInt(24)), Rolls.metronome(actions.p2)[23]);
}

test "Rolls.psywave" {
    const actions: Actions = .{ .p2 = .{ .psywave = 79 } };
    var side = Side.init(&[_]Pokemon{.{
        .species = .Bulbasaur,
        .level = 100,
        .moves = &[_]Move{.Tackle},
    }});

    try expectEqualSlices(u8, &.{0}, Rolls.psywave(actions.p1, &side, .None));
    var rolls = Rolls.psywave(actions.p2, &side, .None);
    try expectEqual(150, rolls[rolls.len - 1]);
    side.stored().level = 81;
    rolls = Rolls.psywave(actions.p2, &side, .None);
    try expectEqual(121, rolls[rolls.len - 1]);
    try expectEqualSlices(u8, &.{0}, Rolls.psywave(actions.p2, &side, .false));
}

/// Empirically determined maximum number of bytes possibly required to store the diff between two
/// Generation I battles.
pub const MAX_DIFFS: usize = 117;

/// The optimal size in bytes required to hold the diff between two Generation I battles.
/// At least as large as MAX_DIFFS.
pub const DIFFS_SIZE = if (builtin.mode == .ReleaseSmall)
    MAX_DIFFS
else
    std.math.ceilPowerOfTwo(usize, MAX_DIFFS) catch unreachable;

/// TODO
pub fn diff(
    a: *const data.Battle(data.PRNG),
    b: *const data.Battle(data.PRNG),
    w: protocol.ByteStream.Writer,
) !usize {
    const pos = w.stream.pos;
    const size = @sizeOf(data.Battle(data.PRNG)) - @sizeOf(data.PRNG);
    assert(size % 2 == 0);
    assert(size / 2 < 255);

    var i: usize = 0;
    while (i < size) : (i += 2) {
        const val = std.mem.bytesAsValue(u16, std.mem.asBytes(a)[i .. i + 2]).*;
        if (val != std.mem.bytesAsValue(u16, std.mem.asBytes(b)[i .. i + 2]).*) {
            try w.writeByte(@intCast(i / 2));
            try w.writeInt(u16, val, endian);
        }
    }

    return w.stream.pos - pos;
}

/// TODO
pub fn patch(battle: *data.Battle(data.PRNG), buf: []u8) void {
    var i: usize = 0;
    while (i < buf.len) : (i += 3) {
        const off = @as(u16, @intCast(buf[i])) * 2;
        const val = std.mem.readInt(u16, @ptrCast(buf[i + 1 .. i + 3]), endian);
        std.mem.writeInt(u16, @ptrCast(std.mem.asBytes(battle)[off .. off + 2]), val, endian);
    }
}
